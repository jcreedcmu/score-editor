\documentclass{article}
\input{prooftree}
\usepackage{stmaryrd}
\input{linear}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\bpush{\mathbf{push}}
\newarrow {Equiv} =====
\def\ups#1{#1^G}
\def\dns#1{#1^B}

\begin{document}

A cache-type is  ${\bf C} = (G, C, B, g, \pi)$ such that
\[
\begin{diagram}
G&\rEmbed^g&C&\rOnto^\pi&B
\end{diagram}
\]
A morphism ${\bf C}_1 \to {\bf C}_2$ is
$f : C_1 \to C_2$ such that we can find $\ups f$, $\dns f$ to make the following commute:
\[\begin{diagram}
G_1&\rEmbed^{g_1}&C_1&\rOnto^{\pi_1}&B_1\\
\dTo<{\ups f}&&\dTo>f&&\dTo>{\dns f}\\
G_2&\rEmbed_{g_2}&C_2&\rOnto_{\pi_2}&B_2\\
\end{diagram}
\]

{\bf Fact}: The choices of $\ups f$ and $\dns f$ are uniquely determined by $f$.

{\bf Proof}: Because $g_2$ is mono and $\pi_1$ is epi.

\vskip1em
\hrule
\vskip1em


A regular cache-type is one where the two morphisms are regular; we have
equalizer and coequalizer diagrams
\[
\begin{diagram}
G&\rEmbed^g&C&\pile{\rTo^{d}\\\rTo_{d'}}&D
\end{diagram}
\qquad
\begin{diagram}
E&\pile{\rTo^{e}\\\rTo_{e'}}&C&\rOnto^\pi&B
\end{diagram}
\]
{\bf Fact}: If ${\bf C}_1, {\bf C}_2$ are regular,
then $f$ is a morphism ${\bf C}_1 \to {\bf C}_2$ iff
$$d_2fg_1 = d'_2 f g_1 \hbox{ and } \pi_2 fe_1 = \pi_2 fe'_1\eqno(*)$$


{\bf Proof}: Reason according to the following diagram, using (co)equalizer property of
$g_2$ and $\pi_1$ to fill in $\ups f$ and $\dns f$.
\[\begin{diagram}
&&G_1&\rDotsto^{\ups f}&G_2\\
&&\dEmbed<{g_1}&&\dEmbed>{g_2}\\
E_1&\pile{\rTo^{e_1}\\\rTo_{e'_1}}&C_1&\rTo^{f}&C_2&\pile{\rTo^{d_2}\\\rTo_{d'_2}}&D_2\\
&&\dOnto<{\pi_1}&&\dOnto>{\pi_2}\\
&&B_1&\rDotsto_{\dns f}&B_2\\
\end{diagram}
\]

%% \[
%% \begin{diagram}
%% G_1&\rEmbed^{g_1}&C_1\\
%% \dEmbed<{g_1}&\rdTo>{\ups f}&&\rdTo>f\\
%% C_1&&G_2&\rEmbed^{g_2}&C_2\\
%% &\rdTo<f&\dEmbed<{g_2}&&\dTo>{\delta_2}\\
%% &&C_2&\rTo_{d_2}&D_2\\
%% \end{diagram}
%% \qquad\qquad
%% \begin{diagram}
%% E_1&\rTo^{e_1}&C_1\\
%% \dTo<{\epsilon_1}&&\dOnto>{\pi_1}&\rdTo>f\\
%% C_1&\rOnto_{\pi_1}&B_1&&C_2\\
%% &\rdTo_{f}&&\rdTo>{\dns f}&\dOnto>{\pi_2}\\
%% &&C_2&\rOnto_{\pi_2}&B_2\\
%% \end{diagram}
%% \]

\vskip1em
\hrule
\vskip1em

We might imagine that we have some types
\[
\begin{diagram}
B&\lEquiv&B\\
\uOnto<{\pi}&\ldEmbed~{\iota}&\dTo>d\\
C&\rTo_{\delta}&D\\
\end{diagram}
\qquad\qquad
\begin{diagram}
G &\rEmbed^{g}_{\textrm{[eq'izer]}}&C&\pile{\rTo^{\delta}\\\rTo_{d\circ\pi}}&D
\end{diagram}
\]
These say how to (maybe inefficiently) derive derived state from the base ($d$), and how to derive it (more efficiently)
from state with extra cache ($\delta$), how to project out the base state from the cache state ($\pi$), and
how to create an empty cache ($\iota$). Note that it's not necessarily the case that $d\pi = \delta$ despite the appearance
of the diagram. Then $\begin{diagram}G&\rEmbed~g&C&\rOnto~\pi&B\end{diagram}$ is a regular cache-type. By construction
$g$ is a regular mono, and $\pi$ is regular epi because it is split epi.


\end{document}
